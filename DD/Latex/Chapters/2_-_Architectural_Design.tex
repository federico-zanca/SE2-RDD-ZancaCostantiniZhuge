\section{Overview}
\label{sec: overview}%
In this section, a general description of the architecture of the \verb|CKB| system is provided.
The main aspects of the design are:
\begin{itemize}
    \item \textbf{Client-Server architecture. } It consists of a presentation tier, an application and a data tier.
    The firsts one allow the user to communicate with the server and shows him through the UI the answers it receives back from the application tier.
    The second one receives requests from users, elaborates answers, changes the status communicating with the data tier and sends back the needed information to users.
    Finally, the data tier stores, updates, and handles the information.
    \item \textbf{Microservices. } Functionalities of the system are divided into several services in order to reduce dependencies between
    modules and to increase scalability, availability and maintainability of the system.
\end{itemize}

\section{Component View}
\label{sec: component_view}%
The component diagram shows all the identified components.
It also describes the relations between the modules, representing the verse of the communication flow and the actors participating.

Bla bla bla

\subsection{Component diagram}
\label{subsec:component_diagram}%
\begin{figure} [H]
    \begin{center}
        \includegraphics[width=1\linewidth]{Images/compdiag.png}
        \caption{Component diagram of the CKB platform.}
        \label{fig: cd}
    \end{center}
\end{figure}

\subsection{Components description}
\label{subsec:components_description}%
The components are:
\begin{itemize}
    \item \textbf{User WebApp.} \verb|User| \verb|WebApp| is the front-end for users. 
    %It allows them to interact with the system by offering the following functions through the interface UserAppI:
    %    \begin{itemize}
    %        \item \textbf{Register} 
    %        \item \textbf{Login} 
    %        \item \textbf{A} 
    %        \item \textbf{Z} 
    %        \item \textbf{Z} 
    %        \item \textbf{Z} 
    %        \item \textbf{Z} 
    %        \item \textbf{Z} 
    %    \end{itemize}
    \item \textbf{UserManager} \verb|UserManager| component offers, through the interface \verb|UserManagerI|, the basic function for handling users:
        \begin{itemize}
            \item \textbf{Register}
            \item \textbf{Login}
            %tanta altra roba di sicuro
        \end{itemize}
        It also provides user information to the \verb|EducatorDashboardManager| component and the \verb|StudentDashboardManager| component depending on the role of the logged user.
    %EducatorDashboardManager
    \item \textbf{Educator Dashboard Manager.} \verb|Educator| \verb|Dashboard| \verb|Manager| handles the main functionalities accessible by an Educator. 
    It allows creating and managing both CodeKataBattles and Tournaments, defining new badges and rules and performing all the operations that an Educator should be able to perform according to the RASD.
    \item \textbf{Badge Manager.} \verb|Badge| \verb|Manager| is used to manage badges, allowing to perform operations such as assigning a badge to a Student, creating new badges and defining new rules and variables to obtain them.
    \item \textbf{Gamification Rules Manager.} \verb|Gamification| \verb|Rules| \verb|Manager| is used to manage rules and variables used to determine winners of badges. 
    This component relies on an external actor, Google Spreadsheet, to allow defining new rules in a simple but effective way (Spreadsheet formulas).
    \item \textbf{Student Dashboard Manager.} \verb|Student| \verb|Dashboard| \verb|Manager| handles the main functionalities accessible by a Student.
    It allows joining and participating in CodeKataBattles and Tournaments, checking the status of the ongoing ones and the results of the past ones.
    \item \textbf{Battle Manager.} \verb|Battle| \verb|Manager| is used to manage CodeKataBattles, allowing to perform operations such as creating a new CodeKataBattle, 
    joining an existing one and checking the status of the ongoing ones through its interface \verb|BattleI|.
    \item \textbf{Tournament Manager.} \verb|Tournament| \verb|Manager| is used to manage Tournaments, allowing to perform operations such as creating a new Tournament,
    joining an existing one and checking the status of the ongoing ones through its interface \verb|TournamentI|. Educators can also add other Educators as admin to a tournament they created.
    \item \textbf{Automated Evaluation Manager.} \verb|Automated| \verb|Evaluation| \verb|Manager| is used to manage the automated evaluation of CodeKataBattles assigning scores to teams.
    \item \textbf{Team Manager.} \verb|Team| \verb|Manager| is used to manage teams, allowing to perform operations such as creating a new team, joining an existing one and inviting a student to join a team.
    %invitations manager
    \item \textbf{Notification Manager.} \verb|Notification| \verb|Manager| allows Students to be notified via email when a new CodeKataBattle or Tournament is created or ends. It relies on an external Mailing Service.
\end{itemize}
External entities are:
\begin{itemize}
    \item \textbf{Google Spreadsheet.} \verb|Google| \verb|Spreadsheets| is the engine used by Educators when creating new rules for badges. 
    \item \textbf{Mailing Service.} \verb|Mailing| \verb|Service| is used to send emails to Students when a new CodeKataBattle or Tournament is created or ends.
    \item \textbf{Github.} \verb|Github| interacts with the \verb|Battle| \verb|Manager| component to handle the code that represents the solution of a CodeKataBattle. 
    CKB platform offers APIs to allow Github Actions Workflow to trigger a pull request to the repository of the solution.
\end{itemize}

\section{Deployment View}
\label{sec: deployment_view}%
The distribution of components capturing the topology of the system is illustrated below by using a deployment diagram.
The system is structured in a multitier architecture.
\newline
\begin{figure} [H]
    \begin{center}
        \includegraphics[width=1\linewidth]{Images/deployment_diag.png}
        \caption{Deployment diagram of the CKB platform.}
        \label{fig: depl_diagram}
    \end{center}
\end{figure}


\noindent\textbf{Laptop devices}\newline
This node represents a user's laptop, which is the client-side hardware. The "Windows OS" indicates that the laptop is running on the Windows operating system. 
The "web browser" is the software application used to access the web interface of the platform.

\noindent\textbf{Firewall}\newline
This is a security device that monitors and filters incoming and outgoing network traffic based on an organization's previously established security policies. 
Here, it acts as a barrier between secure internal networks and untrusted external networks, such as the internet.

\noindent\textbf{Reverse Proxy}\newline
This server is running Nginx, which is a web server that can also be used as a reverse proxy. This means it can distribute traffic to various servers, 
thereby acting as an additional layer of abstraction and control to smooth the flow of network traffic between clients and services.

\noindent\textbf{Webserver 0}\newline
This is one of potentially multiple web servers that handle the incoming HTTP requests from the client's web browser, process those requests, 
and serve the appropriate web pages. It runs on a Linux operating system, which suggests a preference for open-source solutions.

\noindent\textbf{Webserver N}\newline
This indicates there are multiple webservers in this deployment, following a similar configuration to "Webserver 0." 
The "N" represents an indefinite number, showing that the architecture is scalable and can include as many webservers as needed.

\noindent\textbf{SQL database (MySQL)}\newline
This database node uses MySQL, which is a relational database management system (RDBMS) based on SQL (Structured Query Language). 
It's used to store and manage the platform's structured data efficiently.

\noindent\textbf{NoSQL database (MongoDB)}\newline
This is a NoSQL database, specifically MongoDB, which is designed for storing unstructured data. It offers high performance, high availability, and easy scalability.

\noindent\textbf{ckb DBMS}\newline
This artifact within both database nodes represents the database management software that's part of the CodeKataBattle platform. It is likely the collection of schemas, 
tables, queries, reports, views, and other objects associated with the platform's database management.

\section{Runtime View}
\label{sec:runtime_view}%
Here we present the dynamic of our system through sequence diagrams.
We have found the components that communicate with each other to form our system, so now we explain their behaviors.

First, we will present CKB platform actions from the point of view of a general user, i.e., logging in, booking a charge, managing his profile, etc.
Then, we will present CKB platform actions from the point of view of the student and educator, actions that are related to their specific role.
In this section, we hadn't presented all the RASD document use cases because we have decided to focus on the critical part of the system functionalities.

\paragraph{Registered User Login}
When a user WebApp wants to log in to the CKB platform, he calls the ``\verb|logIn|'' function from the \verb|UserManager| component through it's interface.
The \verb|UserManager| component then requests the UserWebApp to display the login form from which, after the user inserted the credentials it sends the information to the
\verb|AuthenticationService| to validate it's correctness. Based on the responce from the \verb|AuthenticationService| the \verb|UserManager| component will send a confirmation or an error to the client.

% Sequence to be made
\begin{comment}

\begin{figure}[H]
    \begin{center}
        \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
        \caption{Registered EVD logs in sequence diagram}
        \label{fig:evd_logs_in}
    \end{center}
\end{figure}
\end{comment}

\paragraph{Student subscribe to a tournament}
When a student wants to subscribe to a open tournament, the User WebApp after login knows that the user is a student so it shows the student the corresponding StudentDashboard.
In the StudentDashboard the student can select a tournament through the list of tournaments and clicks the subscribe button near the selected tournament.
With the interface \verb|TournamentI| the \verb|StudentDashboardManager| calls the subscribe function, the \verb|TournamentManager| will check if in the CKB data base the student has already subscribed.
Only then the \verb|TournamentManager| will sends a corresponding confirmation or an error to the client.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}


\paragraph{Student creates a team}
For students already subscribed in a tournament, they can call the \verb|createTeam| function through the \verb|TeamManagerI| interface.
\verb|TeamManager| component will send a request to the \verb|StudentDashboardManager| for the size and name of the group. After the student has inputed the information, the \verb|TeamManager|
will check the CKB database to ensure there are no teams with the same name already inside the DB. Then it will create the Team and norificate the student of the success or send an error.


% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}


\paragraph{Student invites another student to the team}
After the team has been created, the student can invite other students to join the team. 
The student can call the \verb|inviteStudent| function through the \verb|TeamManagerI| interface.
\verb|TeamManager| component will send a request to the \verb|StudentDashboardManager| for the email of the student to invite. 
After the student has inputed the information, the \verb|TeamManager| will check the CKB database to ensure the student is not already in a team.
Then it will send an email to the student to invite him to the team and norificate the student of the success or send an error.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}

\paragraph{Student accepts or rejects an invitation to join a team}
After receiving an invitation to join a team, a student can accept or reject this invitation by invoking the \verb|acceptInvitation| or \verb|rejectInvitation| function through the \verb|TeamManagerI| interface. 
These functions require specific parameters such as the invitation ID and student ID. The \verb|TeamManager| component processes the request, either adding the student to the team or removing the invitation from the CKB database, depending on the student's decision. 
The \verb|TeamManager| then notifies the student of the outcome. If the operation is successful, a confirmation is sent. If an error occurs, an error message is returned, allowing the student to handle the error appropriately.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}

\paragraph{Student join a battle}
When a student, either individually or as part of a team, wishes to join a battle, they invoke the \verb|joinBattle| function from the \verb|BattleI| interface. This function requires specific parameters such as the battle ID and student or team ID. 
The \verb|BattleManager| receives the request and checks the registration deadline. If the deadline has not passed, the \verb|BattleManager| admits the student or team to the battle and updates the CKB database accordingly. A confirmation is then sent to the client. 
If the deadline has passed or if any other error occurs, an error message is returned to the client, allowing them to handle the error and provide appropriate feedback to the student.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}

\paragraph{Educator creates a tournament}
To create a tournament, the \verb|EducatorDashboardManager| invokes the \verb|createTournament| function from the \verb|TournamentI| interface. 
This function requires specific parameters such as the tournament name, number of participants, and other relevant details. The \verb|createTournament| function then passes the request to the \verb|TournamentManager| component. 
The \verb|TournamentManager| handles the creation of the tournament, including any necessary error checking, and inserts the tournament details into the database. If the tournament creation is successful, a confirmation is returned to the \verb|EducatorDashboardManager|. 
If the creation fails, an error message is returned instead, allowing the \verb|EducatorDashboardManager| to handle the error and provide appropriate feedback to the educator.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}

\paragraph{Educator closes a tournament}
When an educator needs to close a tournament, they can invoke the \verb|closeTournament| function from the \verb|TournamentI| interface. This function requires specific parameters such as the tournament ID. 
The \verb|TournamentManager| component receives the request and processes it by marking the specified tournament as closed in the CKB database. 
During this process, the \verb|TournamentManager| performs necessary checks, such as verifying that the tournament exists and is currently open. If the operation is successful, a confirmation is sent back to the \verb|EducatorDashboardManager|. 
In case of an error, such as the tournament not existing or already being closed, an error message is returned, allowing the \verb|EducatorDashboardManager| to handle the error and provide appropriate feedback to the educator.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}

\paragraph{Educator uploads a CKB}
When an educator needs to upload a CKB, they can invoke the \verb|uploadCKB| function from the \verb|BattleI| interface. This function requires specific parameters such as the CKB file and its associated metadata. 
The \verb|BattleManager| component receives the request and processes it by validating the CKB file and its metadata, and then storing them in the CKB database. 
During this process, the \verb|BattleManager| performs necessary checks, such as verifying the file format and integrity. If the operation is successful, a confirmation is sent back to the \verb|EducatorDashboardManager|. 
In case of an error, such as the file being in an incorrect format or corrupted, an error message is returned, allowing the \verb|EducatorDashboardManager| to handle the error and provide appropriate feedback to the educator.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}

\paragraph{Educator grants permission to another educator}
When an educator needs to grant permission to another educator, they can invoke the \verb|grantPermission| function from the \verb|TournamentI| interface. This function requires specific parameters such as the tournament ID and the educator ID.
The \verb|TournamentManager| component receives the request and processes it by granting the specified educator permission to manage the specified tournament.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}


\paragraph{Educator creates a new rule}
When an educator needs to create a new bagde, they have to create new rules associated with the new badge. They can invoke the \verb|createRule| function from the \verb|GamificationRulesI| interface.
This function requires specific parameters such as the rule name, the rule description and the rule formula. The \verb|GamificationRulesManager| component receives the request and processes it by validating the rule formula and storing it in the CKB database.
During this process, the \verb|GamificationRulesManager| performs necessary checks, such as verifying the formula syntax. If the operation is successful, a confirmation is sent back to the \verb|EducatorDashboardManager|.
In case of an error, such as the formula being in an incorrect format or corrupted, an error message is returned, allowing the \verb|EducatorDashboardManager| to handle the error and provide appropriate feedback to the educator.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}


\paragraph{Educator manually evaluates a team}
When an educator needs to manually evaluate a team, they can invoke the \verb|evaluateTeam| function from the \verb|BattleI| interface. This function requires specific parameters such as the battle ID and the team ID.
The \verb|BattleManager| component receives the request and processes it by evaluating the specified team and updating the CKB database accordingly. If the operation is successful, a confirmation is sent back to the \verb|EducatorDashboardManager|.
In case of an error, such as the team not existing or the battle not being closed, an error message is returned, allowing the \verb|EducatorDashboardManager| to handle the error and provide appropriate feedback to the educator.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}



\paragraph{User visualize tournament rankings}
When a user wants to visualize the rankings of a tournament, they can invoke the \verb|getTournamentRankings| function from the \verb|TournamentI| interface. This function requires specific parameters such as the tournament ID.
The \verb|TournamentManager| component receives the request and processes it by retrieving the rankings of the specified tournament from the CKB database. If the operation is successful, the rankings are sent back to the client.

% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}


\paragraph{User visualize other users' profiles}
When a user wants to visualize the profile of another user, they can invoke the \verb|getUserProfile| function from the \verb|UserManagerI| interface. This function requires specific parameters such as the user ID.
The \verb|UserManager| component receives the request and processes it by retrieving the profile of the specified user from the CKB database. If the operation is successful, the profile is sent back to the client.


% Sequence to be made
\begin{comment}

    \begin{figure}[H]
        \begin{center}
            \includegraphics[width=\linewidth]{SequenceDiagrams/evd_logs_in}
            \caption{Registered EVD logs in sequence diagram}
            \label{fig:evd_logs_in}
        \end{center}
    \end{figure}
\end{comment}

\newpage

\section{Selected architectural styles and patterns}

In this section are shown the most relevant architectural design choices, with also the explanation of their role and their advantages.

\textbf{3 Tier Architecture}\newline
N-tier architecture refers to the structure of a software application divided into multiple tiers. 
A tier is a layer of the application that operates on its own infrastructure or server. 
In particular, we decided to implement a 3-tier architecture. The tiers are: presentation, logic, and data tier.\newline
Presentation tier → It presents information to users and receive user inputs\newline
Logic tier → It handles business logic and application processing logic. It’s responsible for processing user requests, 
applying business rules, and managing the flow of data between the presentation and data tier\newline
Data tier → It manages the storing and retrieving of the data. It handles data persistence and integrity too\newline
The advantages of using this type of architecture revolve around its scalability, ease of management, and flexibility and security. 
If we need to add more resources to a specific tier or modify it, we can do so without affecting the other tiers. Moreover, we can secure each 
of the three tiers separately using different methods and techniques, based on the security needed for the specific tier

\textbf{WebSocket with Pub/Sub Pattern}
The WebSocket protocol provides a full-duplex communication channel over a single TCP connection. 
This means that data can be sent and received at the same time, allowing for real-time communication between the client and the server.
The Publish/Subscribe pattern is a messaging pattern where senders (publishers) categorize messages into classes without knowing which 
subscribers (if any) there might be. Similarly, subscribers express interest in one or more classes, and only receive messages that are of interest, 
without knowing which publishers there are
When combined, WebSocket and Pub/Sub can be a powerful tool for real-time web applications. Regarding the CKB specifically:\newline
1. Publishing → when an event occurs in CKB (e.g., a new battle is created, a score is updated,…), the server publishes a message about this event. 
The message is categorized based on the type of event (e.g., “New Battle”, “Score Updated”,…)\newline
2. Subscribing → Clients (users of CKB) subscribe to the types of events they’re interested in. 
For example, a student might subscribe to “New Battle” events to be notified when a new battle is created.\newline
3. Real-Time Updates → Because the communication is happening over WebSocket, these messages can be pushed from the 
server to the client in real-time. As soon as a new message is published, all clients subscribed to that type of event will receive the message.\newline
4. Scalability → The Pub/Sub pattern allows for scalability. As the number of users (subscribers) and events (publishers) increases, 
the system can continue to function efficiently.\newline
This combination of WebSocket and Pub/Sub can provide a dynamic, real-time user experience for CKB, making it more engaging and responsive for its users.

\textbf{Worker Pooling}
Worker pooling refers to a pattern where a set of initialized “workers” (threads, processes, or any kind of parallel-executing entities) 
are kept ready to perform a certain kind of task. In the context of CKB, worker pooling can help to improve the performance and 
responsiveness of your server by reusing workers instead of creating new ones for each request. This can be particularly helpful in 
a high-load scenario where new requests are coming in faster than the server can create new workers. 
Moreover, thanks to the presence of the reverse proxy, we can obtain a balanced load cross the network. 
Infact, a reverse proxy can distribute incoming requests to multiple server replicas. 
This is done to achieve evenly distributed load across the servers replica, 
preventing any single server from becoming a bottleneck. 
Each replica would have its own worker pool to handle the requests it receives

\textbf{Microservices}
The application uses a suite of small services, instead of being monolithic, 
each running in its own process and communicating with the other microservices. 
To communicate between each other, microservices can exploit an event-driven paradigm (like publisher and subscriber). 
Moreover, other design choice must be taken into consideration, for example to achieve resiliency. 
One suggestion could be to utilize a Circuit Breaker to inhibit all those microservices that are failing repeatedly. 
In the specific context of CKB, this could be momentarily debilitating some functions of the platform, 
such as the possibility to visualize the leaderboard of a Tournament or adding members to a team. 
This way, the platform itself can keep running, and maintenance can be executed on the faulty microservices to bring them back up as quickly as possible

